# -*- coding: utf-8 -*-
"""Jupyter_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GaFJjMptj-JfbC1XEWow2BxFGtGAfBO-
"""



# !pip install opencv-python
# !pip install -U scikit-learn scipy matplotlib

# !pip install sklearn
import cv2 as computer_vision
import matplotlib.pyplot as plt
import os
import numpy as np
count=0

facedetect = computer_vision.CascadeClassifier(computer_vision.data.haarcascades +'haarcascade_frontalface_default.xml')
path='Photo without mask (File responses)-20221020T130934Z-001\Photo without mask (File responses)\IMG_20221014_025317 - deepak siwania[IIT JODHAPUR].jpg'
img1 = computer_vision.imread(path)
print("img1_shape",img1.shape)
plt.imshow(img1)
gray1 = computer_vision.cvtColor(img1, computer_vision.COLOR_BGR2GRAY)
print("gray1_shape",gray1.shape)
plt.imshow(gray1, cmap='gray')
faces1 = facedetect.detectMultiScale(gray1, 1.3, 5)
faces1

faces = facedetect.detectMultiScale(gray1, 1.3, 5)
i=0
while i < len(faces):

    x_cor=faces[i][0]
    y_cor=faces[i][1]
    width=faces[i][2]
    hight=faces[i][3]
    computer_vision.rectangle(img1, (x_cor,y_cor), (x_cor+width, y_cor+hight), (0,255,0), 3)
    i=i+1
plt.imshow(img1, cmap='gray')

import cv2
folder_mask_detection_path='Raw_Image'
# images_array=[]
# mask_class=[]
# testRatio=0.3
imgDimension=(50,50,3)

path0='Cropped_row_image/cropped_umasked/'
path1='Cropped_row_image/cropped_masked/'


myList=os.listdir(folder_mask_detection_path)
print(myList)
numOfClasses=len(myList)
print(numOfClasses)

count = 0

print("Importing Classes..........")
# for x in range(0, 2):
# for x in range(numOfClasses):
x = 0
while x < numOfClasses:

  myPicList = os.listdir(folder_mask_detection_path + "/" + str(x))
  print("myPicList", myPicList)


  #     for y in myPicList:
  k = 0
  while k < len(myPicList):

    #         count=count+1
    picture = myPicList[k]
    print("picture", picture)
    folderImg = cv2.imread(folder_mask_detection_path + "/" + str(x) + "/" +
                           picture)
    #         print("folderImg",folderImg)
    #         folderImg=cv2.resize(folderImg,(imgDimension[0],imgDimension[1]))
    #         print("folderImg",folderImg)

    #         gray = computer_vision.cvtColor(folderImg, computer_vision.COLOR_BGR2GRAY)
    #         images_array.append(folderImg)

    scaleFactor_img = 1.3
    minNeighbors_img = 5
    faces = facedetect.detectMultiScale(folderImg, scaleFactor_img,
                                        minNeighbors_img)
    print("faces", faces)

    if len(faces) != 0:
      i = 0
      print("faces")
      while i < len(faces):

        x_cor = faces[i][0]
        y_cor = faces[i][1]
        width = faces[i][2]
        hight = faces[i][3]
        if x == 0:
          path_of_file = path0 + str(count) + '.jpg'
        else:
          path_of_file = path1 + str(count) + '.jpg'

        print("Savinging Images to path........." + path_of_file)
        computer_vision.imwrite(
          path_of_file, folderImg[y_cor:y_cor + hight, x_cor:x_cor + width])
        #                 computer_vision.rectangle(frame_taken, (x_cor,y_cor), (x_cor+width, y_cor+hight), (0,255,0), 3)
        i = i + 1
        count = count + 1
#         total = total + 1

    k = k + 1
  print(x)
  x = x + 1

count=0

video=computer_vision.VideoCapture(0)


facedetect = computer_vision.CascadeClassifier(computer_vision.data.haarcascades +'haarcascade_frontalface_default.xml')


total=0

while True:
# if total<9:
#     for i in range(total):
#     total=total+1
    flag_value,frame_taken=video.read()
#     total=total+1

#     print(frame_taken)

    scaleFactor_img=1.3
    minNeighbors_img=5
    faces=facedetect.detectMultiScale(frame_taken,scaleFactor_img, minNeighbors_img)
    if len(faces)!=0:
        print(len(faces))
        print((faces))
        for i in range(len(faces)):
            print((faces[i][0]))


#         print((faces[]))



#     print(faces)


    if len(faces)!=0:
        i=0
        while i < len(faces):

            x_cor=faces[i][0]
            y_cor=faces[i][1]
            width=faces[i][2]
            hight=faces[i][3]
            path_of_file='./images/face_without_mask/Sanjeev/'+ str(count) + '.jpg'

            print("Savinging Images to path........." +path_of_file)
            computer_vision.imwrite(path_of_file, frame_taken[y_cor:y_cor+hight,x_cor:x_cor+width])
            computer_vision.rectangle(frame_taken, (x_cor,y_cor), (x_cor+width, y_cor+hight), (0,255,0), 3)
            i=i+1
            count=count+1
            total=total+1

    computer_vision.imshow("Window Frame of webcam", frame_taken)
    computer_vision.waitKey(5)
    if total>100:
        break

video.release()
computer_vision.destroyAllWindows()

face_cascade_file = computer_vision.CascadeClassifier(computer_vision.data.haarcascades +'haarcascade_frontalface_default.xml')
img = computer_vision.imread('Photo wearing face mask (File responses)/IMG_20210122_122524 - Devansh Kaushik.jpg')
gray = computer_vision.cvtColor(img, computer_vision.COLOR_BGR2GRAY)
faces=face_cascade_file.detectMultiScale(gray,1.3, 5)
x_cor,y_cor,width,hight=faces[0][0],faces[0][1],faces[0][2],faces[0][3]
computer_vision.rectangle(img, (x_cor,y_cor), (x_cor+width, y_cor+hight), (0,255,0), 3)
plt.imshow(img, cmap='gray')
faces

# import cv2
# img = cv2.imread('/content/photo_without_mask/20221017_175122 - Sai Akash.jpg')
# img.shape
# plt.imshow(img)
# gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# gray
# gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
# gray1.shape
# plt.imshow(gray, cmap='gray')

import cv2


import sklearn

# from sklearn.model_selection import train_test_split

# !pip install -U scikit-learn scipy matplotlib

folder_mask_detection_path='Mask_detection_folder'
images_array=[]
mask_class=[]
testRatio=0.3
imgDimension=(50,50,3)


myList=os.listdir(folder_mask_detection_path)
print(myList)
numOfClasses=len(myList)
print(numOfClasses)

print("Importing Classes..........")
# for x in range(0, 2):
# for x in range(numOfClasses):
x=0
while x < numOfClasses:
    myPicList=os.listdir(folder_mask_detection_path+"/"+str(x))

#     for y in myPicList:
    i=0
    while i < len(myPicList):
        picture=myPicList[i]
        folderImg=cv2.imread(folder_mask_detection_path+"/"+str(x)+"/"+picture)
        folderImg=cv2.resize(folderImg,(imgDimension[0],imgDimension[1]))
        gray = computer_vision.cvtColor(folderImg, computer_vision.COLOR_BGR2GRAY)
#         images_array.append(folderImg)
        images_array.append(gray)

        mask_class.append(x)
        i=i+1
    print(x)
    x=x+1

images_array=np.array(images_array)
mask_class=np.array(mask_class)

# print(images_array)

# length,size1,size2,color_channel=images_array.shape
length,size1,size2=images_array.shape

print(images_array.shape)
images_array=images_array.reshape(length,size1*size2)
# images_array=images_array.reshape(length,size1*size2*color_channel)

# print(images_array)
print(images_array.shape)

print(mask_class.shape)

print(images_array)
print((mask_class.size))
print(len(images_array))



shuffler = np.random.permutation(len(images_array))
images_array = images_array[shuffler]
mask_class = mask_class[shuffler]
print(images_array)
print(mask_class)

train_size = int(0.7 * len(images_array))
x_train = images_array[:train_size]
x_test = images_array[train_size:]


y_train = mask_class[:train_size]
y_test = mask_class[train_size:]

import numpy as np
from sklearn import svm


classes = 2

model = svm.SVC(kernel = 'linear', random_state = 0, C=1.0)

model.fit(x_train, y_train)



# y=model.predict(test_images_array)
y=model.predict(x_test)

# print(x_test[0].reshape(50,50,3))

# print(x_test[0].size)

# print(x_test[400])
print(y)
print(y_test)
from sklearn import metrics
from sklearn.metrics import accuracy_score
acuracy =accuracy_score(y, y_test)
print(acuracy)


# print(metrics.plot_confusion_matrix(model, x_test, y_test, display_labels=['Negative', 'Positive']))

confusion_matr = metrics.confusion_matrix(y_test, y)
confusion_matr.ravel()

pos_label=1
pos_precision = metrics.precision_score(y_test, y, pos_label=pos_label)
print("pos_precision",pos_precision)

neg_label=0
neg_precision = metrics.precision_score(y_test, y, pos_label=neg_label)
print("neg_precision",neg_precision)
# print(precision_positive, precision_negative)


recall_sensit = metrics.recall_score(y_test, y, pos_label=pos_label)
print("recall_sensitivity",recall_sensit)
recall_specif = metrics.recall_score(y_test, y, pos_label=neg_label)
print("recall_specificity",recall_specif)


f1_pos_score = metrics.f1_score(y_test, y, pos_label=pos_label)
print("f1_positive",f1_pos_score)

f1_neg_score = metrics.f1_score(y_test, y, pos_label=neg_label)
print("f1_negative",f1_neg_score)


print(metrics.classification_report(y_test, y))



data=x_test[0].reshape(50,50)

from matplotlib import pyplot as plt
plt.imshow(data, interpolation='nearest')
plt.show()

# from sklearn.linear_model import LinearRegression
# regr = LinearRegression()

# regr.fit(x_train, y_train)
# print(regr.score(x_test, y_test))

# score =accuracy_score(y, y_test)

from sklearn.neighbors import KNeighborsClassifier
model2 = KNeighborsClassifier(n_neighbors=2)

model2.fit(x_train, y_train)

y_pred=model2.predict(x_test)
# Calculate the accuracy of the model
print(model2.score(x_test, y_test))




print(metrics.plot_confusion_matrix(model, x_test, y_test, display_labels=['Negative', 'Positive']))

confusion_matr = metrics.confusion_matrix(y_test, y_pred)
confusion_matr.ravel()

pos_label=1
pos_precision = metrics.precision_score(y_test, y_pred, pos_label=pos_label)
print("pos_precision",pos_precision)

neg_label=0
neg_precision = metrics.precision_score(y_test, y_pred, pos_label=neg_label)
print("neg_precision",neg_precision)
# print(precision_positive, precision_negative)


recall_sensit = metrics.recall_score(y_test, y_pred, pos_label=pos_label)
print("recall_sensitivity",recall_sensit)
recall_specif = metrics.recall_score(y_test, y_pred, pos_label=neg_label)
print("recall_specificity",recall_specif)


f1_pos_score = metrics.f1_score(y_test, y_pred, pos_label=pos_label)
print("f1_positive",f1_pos_score)

f1_neg_score = metrics.f1_score(y_test, y_pred, pos_label=neg_label)
print("f1_negative",f1_neg_score)


print(metrics.classification_report(y_test, y_pred))

from sklearn.tree import DecisionTreeClassifier
dt_criterion="gini"
dt_random_state = 100
dt_max_depth=3
dt_min_samples_leaf=5

model3 = DecisionTreeClassifier(criterion = dt_criterion,random_state = dt_random_state,max_depth=dt_max_depth,
                                min_samples_leaf=dt_min_samples_leaf)
print(x_train.shape)
print(y_train.shape)
model3.fit(x_train, y_train)
print(x_test.shape)
y=model3.predict(x_test)
# accuracy_score(y_test,y_pred)




from sklearn.metrics import accuracy_score
accuracy =accuracy_score(y, y_test)
print(accuracy)


# print(metrics.plot_confusion_matrix(model, x_test, y_test, display_labels=['Negative', 'Positive']))

confusion_matr = metrics.confusion_matrix(y_test, y)
confusion_matr.ravel()

pos_label=1
pos_precision = metrics.precision_score(y_test, y, pos_label=pos_label)
print("pos_precision",pos_precision)

neg_label=0
neg_precision = metrics.precision_score(y_test, y, pos_label=neg_label)
print("neg_precision",neg_precision)
# print(precision_positive, precision_negative)


recall_sensit = metrics.recall_score(y_test, y, pos_label=pos_label)
print("recall_sensitivity",recall_sensit)
recall_specif = metrics.recall_score(y_test, y, pos_label=neg_label)
print("recall_specificity",recall_specif)


f1_pos_score = metrics.f1_score(y_test, y, pos_label=pos_label)
print("f1_positive",f1_pos_score)

f1_neg_score = metrics.f1_score(y_test, y, pos_label=neg_label)
print("f1_negative",f1_neg_score)


print(metrics.classification_report(y_test, y))

from sklearn import linear_model
model4 = linear_model.LogisticRegression()
print(x_train.shape)
print(y_train.shape)
model4.fit(x_train, y_train)
print(x_test.shape)
y=model4.predict(x_test)
accuracy_score(y_test,y_pred)



accuracy =accuracy_score(y, y_test)
print(accuracy)


# print(metrics.plot_confusion_matrix(model, x_test, y_test, display_labels=['Negative', 'Positive']))

confusion_matr = metrics.confusion_matrix(y_test, y)
confusion_matr.ravel()

pos_label=1
pos_precision = metrics.precision_score(y_test, y, pos_label=pos_label)
print("pos_precision",pos_precision)

neg_label=0
neg_precision = metrics.precision_score(y_test, y, pos_label=neg_label)
print("neg_precision",neg_precision)
# print(precision_positive, precision_negative)


recall_sensit = metrics.recall_score(y_test, y, pos_label=pos_label)
print("recall_sensitivity",recall_sensit)
recall_specif = metrics.recall_score(y_test, y, pos_label=neg_label)
print("recall_specificity",recall_specif)


f1_pos_score = metrics.f1_score(y_test, y, pos_label=pos_label)
print("f1_positive",f1_pos_score)

f1_neg_score = metrics.f1_score(y_test, y, pos_label=neg_label)
print("f1_negative",f1_neg_score)


print(metrics.classification_report(y_test, y))

from sklearn.naive_bayes import GaussianNB
model5_gnb = GaussianNB()
print(x_train.shape)
print(y_train.shape)
model5_gnb.fit(x_train, y_train)
print(x_test.shape)
y_pred = model5_gnb.predict(x_test)
accuracy_score(y_test, y_pred)


y=model5_gnb.predict(x_test)
accuracy_score(y_test,y_pred)



accuracy =accuracy_score(y, y_test)
print(accuracy)


# print(metrics.plot_confusion_matrix(model, x_test, y_test, display_labels=['Negative', 'Positive']))

confusion_matr = metrics.confusion_matrix(y_test, y)
confusion_matr.ravel()

pos_label=1
pos_precision = metrics.precision_score(y_test, y, pos_label=pos_label)
print("pos_precision",pos_precision)

neg_label=0
neg_precision = metrics.precision_score(y_test, y, pos_label=neg_label)
print("neg_precision",neg_precision)
# print(precision_positive, precision_negative)


recall_sensit = metrics.recall_score(y_test, y, pos_label=pos_label)
print("recall_sensitivity",recall_sensit)
recall_specif = metrics.recall_score(y_test, y, pos_label=neg_label)
print("recall_specificity",recall_specif)


f1_pos_score = metrics.f1_score(y_test, y, pos_label=pos_label)
print("f1_positive",f1_pos_score)

f1_neg_score = metrics.f1_score(y_test, y, pos_label=neg_label)
print("f1_negative",f1_neg_score)


print(metrics.classification_report(y_test, y))



# folder_mask_detection_path='Mask_detection_folder'
folder_mask_detection_path='Test_Mask_detection_folder'
images_array_test=[]
mask_class_test=[]
testRatio=0.3
imgDimension=(50,50,3)


myList=os.listdir(folder_mask_detection_path)
print(myList)
numOfClasses=len(myList)
print(numOfClasses)


print("Importing folder class..........")
# for x in range(0, 2):
# for x in range(numOfClasses):
x=0
while x < numOfClasses:
    myPicList=os.listdir(folder_mask_detection_path+"/"+str(x))

#     for y in myPicList:
    i=0
    while i < len(myPicList):
        picture=myPicList[i]
        folderImg=cv2.imread(folder_mask_detection_path+"/"+str(x)+"/"+picture)
        folderImg=cv2.resize(folderImg,(imgDimension[0],imgDimension[1]))
#         gray = computer_vision.cvtColor(folderImg, computer_vision.COLOR_BGR2GRAY)
        images_array_test.append(folderImg)
#         images_array_test.append(gray)

        mask_class_test.append(x)
        i=i+1
    print(x)
    x=x+1

images_array_test=np.array(images_array_test)
images_array_test.tofile('data_image.csv', sep = ',')
mask_class_test=np.array(mask_class_test)
mask_class_test.tofile('data_output.csv', sep = ',')

# print(images_array)

length,size1,size2,color_channel=images_array_test.shape
# length,size1,size2=images_array_test.shape

print(images_array_test.shape)
# images_array_test=images_array_test.reshape(length,size1*size2)
images_array_test=images_array_test.reshape(length,size1*size2*color_channel)

# print(images_array)
print(images_array_test.shape)

print(mask_class_test.shape)
print(len(mask_class_test))


shuffler = np.random.permutation(len(mask_class_test))
images_array_test = images_array_test[shuffler]
mask_class_test = mask_class_test[shuffler]
print(images_array_test)
print(mask_class_test)

train_size = int(0.7 * len(images_array_test))
x_train1 = images_array_test[:train_size]
x_test1 = images_array_test[train_size:]


y_train1 = mask_class_test[:train_size]
y_test1 = mask_class_test[train_size:]



import numpy as np
from sklearn.datasets import make_classification
from sklearn import svm
from sklearn.model_selection import train_test_split

classes = 2

test_model1 = svm.SVC(kernel = 'linear', random_state = 0, C=1.0)

test_model1.fit(x_train1, y_train1)



# y=model.predict(test_images_array)
y1=test_model1.predict(x_test1)

# print(x_test[0].reshape(50,50,3))

# print(x_test[0].size)

# print(x_test[400])
print(y1)
print(y_test1)
# from sklearn.metrics import accuracy_score
# score1 =accuracy_score(y1, y_test1)
# print(score1)











# Now we will try to predict the face of unmasked person

path='images/face_without_mask'
images_array=[]
studen_label=[]
testRatio=0.3
# valRatio=0.2
imgDimension=(50,50,3)


myList=os.listdir(path)
print(myList)
numOfClasses=len(myList)
print(numOfClasses)

path='images/face_without_mask'
face_detect_array=[]
studen_label=[]
testRatio=0.3
# valRatio=0.2
imgDimension=(50,50,3)


myList=os.listdir(path)
print(myList)
numOfClasses=len(myList)
print(numOfClasses)

print("Importing All folder of StudentData..........")
# for x in range(numOfClasses):
x=0
while x < numOfClasses:
    myPicList=os.listdir(path+"/"+myList[x])
    # myData/0/img.jpg

    i=0
    while i < len(myPicList):
        picture=myPicList[i]
        folderImg=cv2.imread(path+"/"+myList[x]+"/"+picture)
        folderImg=cv2.resize(folderImg,(imgDimension[0],imgDimension[1]))
        face_detect_array.append(folderImg)
        studen_label.append(myList[x])
        i=i+1
    print(myList[x])
    x=x+1

face_detect_array=np.array(face_detect_array)
studen_label=np.array(studen_label)

# print(images_array)

l,n,m,c=face_detect_array.shape
print(face_detect_array.shape)
print(studen_label.shape)
face_detect_array=face_detect_array.reshape(l,m*n*c)
# print(images_array)
print(face_detect_array.shape)

print(studen_label)
print(np.unique(studen_label))

# !pip install pandas

import pandas as pd
df = pd.DataFrame(studen_label, columns = ['Names'])
df2 = df.replace({'Abhilekh':'0', 'Akash':'1','Aviral':'2', 'Deepak':'3', 'Jyothi':'4',
                                 'Sanjeev':'5','Sukitha':'6','Tanmay':'7','Vandita':'8'})

df2

studen_label= np.array(df2)
studen_label

studen_label=studen_label.ravel()
studen_label

from sklearn.model_selection import train_test_split
testRatio=0.30
x_train_fd, x_test_fd, y_train_fd, y_test_fd=train_test_split(face_detect_array, studen_label,
                                                              test_size=testRatio,random_state=101)

import numpy as np
from sklearn.datasets import make_classification
from sklearn import svm
from sklearn.model_selection import train_test_split

classes = 2
ker='linear'
rand_st=0
model_face_detection = svm.SVC(kernel = ker, random_state = rand_st, C=1.0)

model_face_detection.fit(x_train_fd, y_train_fd)



# y=model.predict(test_images_array)
y_fd=model_face_detection.predict(x_test_fd)

# print(x_test[0].reshape(50,50,3))

# print(x_test[0].size)

# print(x_test[400])
# print(y_fd)
# print(y_test_fd)
# from sklearn.metrics import accuracy_score
# score_fd =accuracy_score(y_fd, y_test_fd)
# print(score_fd)



#Now we can check the live maskdetection

# ## haar_data = cv2.CascadeClassifier('data.xml')
# ({'Abhilekh':'0', 'Akash':'1','Aviral':'2', 'Deepak':'3', 'Jyothi':'4',
#                                  'Sanjeev':'5','Sukitha':'6','Tanmay':'7','Vandita':'8'})
mask_check={1:'Mask',0: 'No_Mask'}
face_names={'0':'Abhilekh', '1':'Akash','2':'Aviral', '3':'Deepak', '4':'Jyothi',
                                 '5':'Sanjeev','6':'Sukitha','7':'Tanmay','8':'Vandita'}

import cv2

capture=cv2.VideoCapture(0)

# facedetect=cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
# facedetect = cv2.CascadeClassifier(cv2.data.haarcascades +'haarcascade_frontalface_default.xml')
facedetect = computer_vision.CascadeClassifier(computer_vision.data.haarcascades +'haarcascade_frontalface_default.xml')



# count=0


data= []

# capture = cv2.VideoCapture(8)
font = cv2.FONT_HERSHEY_COMPLEX
# flag1=True
# flag, img2 =capture.read()
i=0
sum1=0
while True:
#     flag, img2 =capture.read()
    flag_value,img2=capture.read()

    if flag_value:
#         faces=face.detectMultiScale(img2)
        faces=facedetect.detectMultiScale(img2)
#         for x,y,w,h in faces:

        if len(faces)!=0:
            i=0
            while i < len(faces):

                x=faces[i][0]
                y=faces[i][1]
                w=faces[i][2]
                h=faces[i][3]
                cv2.rectangle(img2, (x,y), (x+w, y+h), (255,8,255), 4)
                face= img2[y:y+h, x:x+w, :]
                face=cv2.resize(face, (50,50))
                face=face.reshape(1,-1)
    #             pred=svm.predict(face)[0]
                pred=test_model1.predict(face)[0]
#                 if (int(pred)==0):
#                     pred_face=model_face_detection.predict(face)[0]

    #             sum1=sum1+int(pred)

                n=mask_check[int (pred)]
#                 m=face_names[pred_face]

                cv2.putText(img2, n, (x,y), font, 1, (244,250,250), 2)
#                 cv2.putText(img2, m, (x+2,y-25), font, 1, (244,250,250), 2)
                i=i+1

#             print(n)
        cv2.imshow('Window Frame of webcam', img2)
#         i=i+1
#         if sum1>60:
#             print("Masked Confirmed")
#             break

        #27- ASCII of Escope
        if cv2.waitKey(2) == 27:
            sum
            break

capture.release()
cv2.destroyAllWindows()

# Now we will try for face detection for nonmasked person



# ## haar_data = cv2.CascadeClassifier('data.xml')
# ({'Abhilekh':'0', 'Akash':'1','Aviral':'2', 'Deepak':'3', 'Jyothi':'4',
#                                  'Sanjeev':'5','Sukitha':'6','Tanmay':'7','Vandita':'8'})
mask_check={1:'Mask',0: 'No_Mask'}
face_names={'0':'Abhilekh', '1':'Akash','2':'Aviral', '3':'Deepak', '4':'Jyothi',
                                 '5':'Sanjeev','6':'Sukitha','7':'Tanmay','8':'Vandita'}

import cv2

capture=cv2.VideoCapture(0)

# facedetect=cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
# facedetect = cv2.CascadeClassifier(cv2.data.haarcascades +'haarcascade_frontalface_default.xml')
facedetect = computer_vision.CascadeClassifier(computer_vision.data.haarcascades +'haarcascade_frontalface_default.xml')



# count=0


data= []

# capture = cv2.VideoCapture(8)
font = cv2.FONT_HERSHEY_COMPLEX
# flag1=True
# flag, img2 =capture.read()
i=0
sum1=0
while True:
#     flag, img2 =capture.read()
    flag_value,img2=capture.read()

    if flag_value:
#         faces=face.detectMultiScale(img2)
        faces=facedetect.detectMultiScale(img2)
#         for x,y,w,h in faces:

        if len(faces)!=0:
            i=0
            while i < len(faces):

                x=faces[i][0]
                y=faces[i][1]
                w=faces[i][2]
                h=faces[i][3]
                cv2.rectangle(img2, (x,y), (x+w, y+h), (255,8,255), 4)
                face= img2[y:y+h, x:x+w, :]
                face=cv2.resize(face, (50,50))
                face=face.reshape(1,-1)
    #             pred=svm.predict(face)[0]
                pred=test_model1.predict(face)[0]
                if (int(pred)==0):
                    pred_face=model_face_detection.predict(face)[0]
                    m=face_names[pred_face]
                    cv2.putText(img2, m, (x+2,y-25), font, 1, (244,250,250), 2)

    #             sum1=sum1+int(pred)

                n=mask_check[int (pred)]


                cv2.putText(img2, n, (x,y), font, 1, (244,250,250), 2)

                i=i+1

#             print(n)
        cv2.imshow('Window Frame of webcam', img2)
#         i=i+1
#         if sum1>60:
#             print("Masked Confirmed")
#             break

        #27- ASCII of Escope
        if cv2.waitKey(2) == 27:
            sum
            break

capture.release()
cv2.destroyAllWindows()







